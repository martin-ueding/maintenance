#!/usr/bin/python3
# -*- coding: utf-8 -*-

# Copyright © 2012-2013 Martin Ueding <dev@martin-ueding.de>

import argparse
import datetime
import dateutil.parser
import glob
import json
import os
import os.path
import subprocess
import sys
import prettytable

import colorcodes

__docformat__ = "restructuredtext en"

_c = colorcodes.Colorcodes()


def perform(command, dry, data, statusfile):
    """
    Performs a single task.

    :param command: Command to run.
    :type command: str
    :param dry: Whether to only print command.
    :type dry: bool
    :param data: Whole data.
    :type data: list
    :param statusfile: Filename of status file.
    :type statusfile: str
    """
    task = os.path.basename(command)
    print(_c.bold + task + _c.reset)
    print(_c.bold + ("="*len(task)) + _c.reset)
    if not dry:
        try:
            syscommand = 'maintenance-{}'.format(command)
            subprocess.check_call([syscommand])
        except subprocess.CalledProcessError as e:
            print(_c.red + "Error in {command}:".format(command=command) + _c.reset)
            print(e)
        except OSError as e:
            print(_c.red + "Could not execute {command}.".format(command=command) + _c.reset)
            pass
        else:
            if not task in data:
                data[task] = {}

            data[task]["last"] = str(datetime.datetime.now())


def print_tasks(tasks):
    fields = list(list(tasks.items())[0][1].keys())
    table = prettytable.PrettyTable(['command'] + fields)
    table.align = 'l'
    table.align['interval'] = 'r'
    for command, task in sorted(tasks.items()):
        table.add_row([command] + list(task.values()))

    print(table)


def main():
    options = _parse_args()

    taskfile = 'tasks.js'
    tasks = {}
    with open(taskfile) as f:
        tasks = json.load(f)
    print_tasks(tasks)

    if not pre_check() and not options.f:
        print("Aborting. You can use “-f” to run anyway.")
        sys.exit(1)

    statusfile = os.path.expanduser("~/.local/share/maintenance.js")
    data = {}
    if os.path.isfile(statusfile):
        with open(statusfile) as f:
            data = json.load(f)

    for command, attributes in tasks.items():
        needs = True

        if task in data:
            diff = datetime.datetime.now() - dateutil.parser.parse(data[command]["last"])
            if diff < datetime.timedelta(attributes['interval']):
                needs = False

        if not needs:
            continue

        perform(command, options.dry, data, statusfile)


def save_data(statusfile, data):
    """
    Saves all the data.

    :param statusfile: Filename of status file.
    :type statusfile: str
    :param data: Data to save.
    :type: list
    """
    with open(statusfile, "w") as f:
        json.dump(data, f, indent=4, sort_keys=True)


def pre_check():
    """
    Checks whether internet connection and power are attached.

    :return: Whether both internet and power are connected.
    :rtype: bool
    """
    powered = False
    with open("/sys/class/power_supply/AC/online") as f:
        powered = int(f.read()) != 0

    if not powered:
        print(_c.red + "Power not connected." + _c.reset)
        #return False

    connected = False

    try:
        subprocess.check_output(["ping", "-c", "1", "-w", "2",
                                 "martin-ueding.de"])
    except subprocess.CalledProcessError:
        print(_c.red + "No internet connection." + _c.reset)
        return False
    else:
        connected = True

    return connected and powered


def _parse_args():
    """
    Parses the command line arguments.

    :return: Namespace with arguments.
    :rtype: Namespace
    """
    parser = argparse.ArgumentParser(description="Runs periodic tasks and logs that they are done.")
    parser.add_argument("-n", action="store_true", dest="dry", default=False, help="Dry run, only show what would be done.")
    parser.add_argument("-f", action="store_true", help="Run even without power and internet connection.")

    return parser.parse_args()


if __name__ == "__main__":
    main()
