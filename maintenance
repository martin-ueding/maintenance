#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright Â© 2012 Martin Ueding <dev@martin-ueding.de>

import argparse
import datetime
import dateutil.parser
import glob
import json
import os
import os.path
import subprocess

import colorcodes

__docformat__ = "restructuredtext en"

_c = colorcodes.Colorcodes()

def perform(command, dry, data, statusfile):
    print _c.bold + command.center(80) + _c.reset
    print _c.bold + ("="*len(command)).center(80) + _c.reset
    if not dry:
        try:
            subprocess.check_call([command])
        except subprocess.CalledProcessError as e:
            print _c.red + "Error in {command}:".format(command=command) + _c.reset
            print e
        except OSError as e:
            print _c.red + "Could not execute {command}.".format(command=command) + _c.reset
            pass
        else:
            task = command.split('/')[-1]
            if not task in data:
                data[task] = {}

            data[task]["last"] = str(datetime.datetime.now())

            save_data(statusfile, data)
    print


def main():
    options = _parse_args()

    statusfile = os.path.expanduser("~/.local/share/maintenance.js")

    data = {}

    if os.path.isfile(statusfile):
        with open(statusfile) as f:
            data = json.load(f)

    if len(options.periodics) == 0:
        # Automatic modus.
        for periodic in ["daily", "weekly", "monthly", "quarterly", "annually"]:
            for task in os.listdir(periodic):
                if task.startswith("."):
                    continue

                command = os.path.join(periodic, task)

                needs = True

                if task in data:
                    diff = datetime.datetime.now() - dateutil.parser.parse(data[task]["last"])
                    if periodic == "daily" and diff < datetime.timedelta(1):
                        needs = False
                    elif periodic == "weekly" and diff < datetime.timedelta(7):
                        needs = False
                    elif periodic == "monthly" and diff < datetime.timedelta(30):
                        needs = False
                    elif periodic == "quarterly" and diff < datetime.timedelta(90):
                        needs = False
                    elif periodic == "annually" and diff < datetime.timedelta(360):
                        needs = False

                if not needs:
                    continue

                perform(command, options.dry, data, statusfile)

    else:
        # Do what the user told.
        for periodic in options.periodics:
            for task in os.listdir(periodic):
                if task.startswith("."):
                    continue
                command = os.path.join(periodic, task)
                perform(command, options.dry, data, statusfile)

def save_data(statusfile, data):
    with open(statusfile, "w") as f:
        json.dump(data, f, indent=4, sort_keys=True)

def _parse_args():
    """
    Parses the command line arguments.

    :return: Namespace with arguments.
    :rtype: Namespace
    """
    parser = argparse.ArgumentParser(description="Runs periodic tasks and logs that they are done.")
    parser.add_argument("periodics", metavar="periodics", type=str, nargs="*", help="If any of these are specified, overrides the automatic selection. Possible values: daily, weekly, monthly, quarterly")
    parser.add_argument("-n", action="store_true", dest="dry", default=False, help="Dry run, only show what would be done.")

    return parser.parse_args()

if __name__ == "__main__":
    main()
