#!/usr/bin/python3
# -*- coding: utf-8 -*-

# Copyright © 2012-2013 Martin Ueding <dev@martin-ueding.de>

import argparse
import datetime
import dateutil.parser
import glob
import json
import os
import os.path
import prettytable
import subprocess
import sys
import threading
import time

import colorcodes

__docformat__ = "restructuredtext en"

_c = colorcodes.Colorcodes()

statusfile = os.path.expanduser("~/.local/share/maintenance.js")
data = {}
save_data_lock = threading.Lock()
print_lock = threading.Lock()

class Task(threading.Thread):
    def __init__(self, command, attributes, options):
        """
        :param command: Command to run.
        :type command: str
        :param attributes: Attributes of this task.
        :type attributes: dict
        :param dry: Whether to only print command.
        :type dry: bool
        """
        super().__init__()
        self.command = command
        self.attributes = attributes
        self.options = options

    def run(self):
        """
        Performs a single task.
        """
        task = os.path.basename(self.command)
        output = [] 
        run = True

        output.append("")
        output.append(_c.bold + task + _c.reset)
        output.append(_c.bold + ("="*len(task)) + _c.reset)

        internet, power = pre_check()

        if (self.attributes['internet'] and not internet) or self.options.f:
            run = False
            output.append("Aborting this task. You can use “-f” to run it anyway.")

        if run and not self.options.dry:
            try:
                syscommand = 'maintenance-{}'.format(self.command)
                output.append(subprocess.check_output([syscommand]).decode())
            except subprocess.CalledProcessError as e:
                output.append(_c.red + "Error in {command}:".format(command=syscommand) + _c.reset)
                output.append(e)
            except OSError as e:
                output.append(_c.red + "Could not execute {command}.".format(command=syscommand) + _c.reset)
                pass
            else:
                if save_data_lock.acquire():
                    if not task in data:
                        data[task] = {}
                    data[task]["last"] = str(datetime.datetime.now())
                    save_data()
                else:
                    print("Error locking!")
                save_data_lock.release()


        if print_lock.acquire():
            for line in output:
                print(line)
        print_lock.release()


def print_tasks(tasks):
    fields = list(list(tasks.items())[0][1].keys())
    table = prettytable.PrettyTable(['command'] + fields)
    table.align = 'l'
    table.align['interval'] = 'r'
    for command, task in sorted(tasks.items()):
        table.add_row([command] + list(task.values()))

    print(table)

class ProgressThread(threading.Thread):
    def __init__(self, thread_list):
        super().__init__()
        self.thread_list = thread_list
        self.keep_running = True

    def run(self):
        old_output = ""
        while self.keep_running:
            alive = []

            for thread in self.thread_list:
                if not thread.is_alive():
                    continue
                alive.append(thread.command)

            output = ", ".join(sorted(alive))

            if output != old_output:
                old_output = output
                if print_lock.acquire():
                    print(_c.green + "Running:", output + _c.reset)
                    print_lock.release()

            time.sleep(1)


def main():
    options = _parse_args()

    taskfile = '/etc/maintenance/tasks.js'
    tasks = {}
    with open(taskfile) as f:
        tasks = json.load(f)

    if os.path.isfile(statusfile):
        with open(statusfile) as f:
            data = json.load(f)

    print(data)

    threads_disk = []
    threads_nodisk = []
    for command, attributes in tasks.items():
        needs = True

        if command in data:
            diff = datetime.datetime.now() - dateutil.parser.parse(data[command]["last"])
            if diff < datetime.timedelta(attributes['interval']):
                needs = False

        if not needs:
            continue

        thread = Task(command, attributes, options) 
        if attributes['disk']:
            threads_disk.append(thread)
        else:
            threads_nodisk.append(thread)

    print("Tasks that are done this session:")
    print()
    tasks = sorted([thread.command for thread in threads_disk + threads_nodisk])
    for task in tasks:
        print("-", task)
    print()

    progress_thread = ProgressThread(threads_disk + threads_nodisk)
    progress_thread.start()

    # Start all the threads that do not use the disk very much.
    for thread in threads_nodisk:
        thread.start()

    # Start one thread that uses the disk and wait for that.
    for thread in threads_disk:
        thread.start()
        thread.join()

    # Wait for all other threads. I guess that they will have finished by then
    # anyway.
    for thread in threads_nodisk:
        thread.join()

    progress_thread.keep_running = False
    progress_thread.join()


def save_data():
    """
    Saves all the data.
    """
    print("Saving", data)
    with open(statusfile, "w") as f:
        json.dump(data, f, indent=4, sort_keys=True)


def pre_check():
    """
    Checks whether internet connection and power are attached.

    :return: Whether internet and power are connected.
    :rtype: tuple
    """
    powered = False
    with open("/sys/class/power_supply/AC/online") as f:
        powered = int(f.read()) != 0

    if not powered:
        print(_c.red + "Power not connected." + _c.reset)
        #return False

    connected = False

    try:
        subprocess.check_output(["ping", "-c", "1", "-w", "2",
                                 "martin-ueding.de"])
    except subprocess.CalledProcessError:
        print(_c.red + "No internet connection." + _c.reset)
    else:
        connected = True

    return connected, powered


def _parse_args():
    """
    Parses the command line arguments.

    :return: Namespace with arguments.
    :rtype: Namespace
    """
    parser = argparse.ArgumentParser(description="Runs periodic tasks and logs that they are done.")
    parser.add_argument("-n", action="store_true", dest="dry", default=False, help="Dry run, only show what would be done.")
    parser.add_argument("-f", action="store_true", help="Run even without power and internet connection.")

    return parser.parse_args()


if __name__ == "__main__":
    main()
