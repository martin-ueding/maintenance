#!/usr/bin/python3
# -*- coding: utf-8 -*-

# Copyright © 2012-2013 Martin Ueding <dev@martin-ueding.de>

import argparse
import datetime
import dateutil.parser
import glob
import json
import os
import os.path
import prettytable
import subprocess
import sys
import threading
import time

import colorcodes

__docformat__ = "restructuredtext en"

_c = colorcodes.Colorcodes()

statusfile = os.path.expanduser("~/.local/share/maintenance.js")
save_data_lock = threading.Lock()
print_lock = threading.Lock()

all_threads = []

def print_block(lines):
    if print_lock.acquire():
        print()
        for line in lines:
            print(line)
        print_lock.release()

class Task(threading.Thread):
    def __init__(self, command, attributes, options, data):
        """
        :param command: Command to run.
        :type command: str
        :param attributes: Attributes of this task.
        :type attributes: dict
        :param dry: Whether to only print command.
        :type dry: bool
        """
        super().__init__()
        self.command = command
        self.attributes = attributes
        self.options = options
        self.data = data
        self.done = False

    def run(self):
        """
        Performs a single task.
        """
        task = os.path.basename(self.command)
        output = [] 
        run = True

        output.append(_c.bold + task + _c.reset)
        output.append(_c.bold + ("="*len(task)) + _c.reset)
        output.append("")

        internet, power = pre_check()

        if (self.attributes['internet'] and not internet) or self.options.f:
            run = False
            output.append("Aborting this task. You can use “-f” to run it anyway.")

        if run and not self.options.dry:
            syscommand = 'maintenance-{}'.format(self.command)
            # If this is a disk heavy task, show the output right away.
            if self.attributes['disk']:
                print_block(output)
                output = []
                try:
                    if print_lock.acquire():
                        subprocess.check_call([syscommand])
                except subprocess.CalledProcessError as e:
                    print_lock.release()
                    output.append(_c.red + "Error in {command}:".format(command=syscommand) + _c.reset)
                    output.append(e)
                except OSError as e:
                    print_lock.release()
                    output.append(_c.red + "Could not execute {command}.".format(command=syscommand) + _c.reset)
                else:
                    print_lock.release()
                    if save_data_lock.acquire():
                        if not task in self.data:
                            self.data[task] = {}
                        self.data[task]["last"] = str(datetime.datetime.now())
                        save_data(self.data)
                        save_data_lock.release()
                    else:
                        print_block(["Error locking!"])
            else:
                try:
                    output.append(subprocess.check_output([syscommand], stderr=subprocess.STDOUT).decode())
                except subprocess.CalledProcessError as e:
                    output.append(_c.red + "Error in {command}:".format(command=syscommand) + _c.reset)
                    output.append(e)
                except OSError as e:
                    output.append(_c.red + "Could not execute {command}.".format(command=syscommand) + _c.reset)
                else:
                    if save_data_lock.acquire():
                        if not task in self.data:
                            self.data[task] = {}
                        self.data[task]["last"] = str(datetime.datetime.now())
                        save_data(self.data)
                        save_data_lock.release()
                    else:
                        print_block(["Error locking!"])

        print_block(output)
        self.done = True

        print_running_tasks(without=self)


def print_tasks(tasks):
    fields = list(list(tasks.items())[0][1].keys())
    table = prettytable.PrettyTable(['command'] + fields)
    table.align = 'l'
    table.align['interval'] = 'r'
    for command, task in sorted(tasks.items()):
        table.add_row([command] + list(task.values()))

    print_block([table])

def print_running_tasks(without=None):
    alive = []
    waiting = []

    for thread in all_threads:
        if thread.is_alive() and thread is not without:
            alive.append(thread.command)
        elif not thread.done:
            waiting.append(thread.command)

    lines = []

    if len(alive) > 0:
        lines.append(_c.green + "Running: " + ", ".join(sorted(alive)) + _c.reset)
    if len(waiting) > 0:
        lines.append(_c.orange + "Waiting: " + ", ".join(sorted(waiting)) + _c.reset)

    output = "\n".join(lines)
    print_block([output])

def main():
    options = _parse_args()

    taskfile = '/etc/maintenance/tasks.js'
    tasks = {}
    with open(taskfile) as f:
        tasks = json.load(f)

    data = {}
    if os.path.isfile(statusfile):
        with open(statusfile) as f:
            data = json.load(f)

    threads_disk = []
    threads_nodisk = []
    for command, attributes in tasks.items():
        needs = True

        if command in data:
            diff = datetime.datetime.now() - dateutil.parser.parse(data[command]["last"])
            if diff < datetime.timedelta(attributes['interval']):
                needs = False

        if options.local and not attributes["local"]:
            needs = False

        if not needs:
            continue

        thread = Task(command, attributes, options, data) 
        if attributes['disk']:
            threads_disk.append(thread)
        else:
            threads_nodisk.append(thread)

    print_block(["Tasks that are done this session:"])
    tasks = sorted([thread.command for thread in threads_disk + threads_nodisk])
    print_block(["- {}".format(task) for task in tasks])

    global all_threads
    all_threads = threads_disk + threads_nodisk

    # Start all the threads that do not use the disk very much.
    for thread in threads_nodisk:
        thread.start()

    print_running_tasks()

    # Start one thread that uses the disk and wait for that.
    for thread in threads_disk:
        thread.start()
        thread.join()

    # Wait for all other threads. I guess that they will have finished by then
    # anyway.
    for thread in threads_nodisk:
        thread.join()


def save_data(data):
    """
    Saves all the data.
    """
    with open(statusfile, "w") as f:
        json.dump(data, f, indent=4, sort_keys=True)


def pre_check():
    """
    Checks whether internet connection and power are attached.

    :return: Whether internet and power are connected.
    :rtype: tuple
    """
    powered = True

    powerfile = "/sys/class/power_supply/AC/online"
    if os.path.isfile(powerfile):
        with open(powerfile) as f:
            powered = int(f.read()) != 0

    connected = False

    try:
        subprocess.check_output(["ping", "-c", "1", "-w", "2",
                                 "martin-ueding.de"], stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError:
        pass
    else:
        connected = True

    return connected, powered


def _parse_args():
    """
    Parses the command line arguments.

    :return: Namespace with arguments.
    :rtype: Namespace
    """
    parser = argparse.ArgumentParser(description="Runs periodic tasks and logs that they are done.")
    parser.add_argument("-n", action="store_true", dest="dry", default=False, help="Dry run, only show what would be done.")
    parser.add_argument("-f", action="store_true", help="Run even without power and internet connection.")
    parser.add_argument("--local", action="store_true", help="Run only local tasks.")

    return parser.parse_args()


if __name__ == "__main__":
    main()
