#!/usr/bin/python3
# -*- coding: utf-8 -*-

# Copyright © 2012-2013 Martin Ueding <dev@martin-ueding.de>

'''
Goes through the folder with my projects, exports the current git tags with
``git tarball`` into the packaging folder. Then it uses ``uupdate`` and
``debuild``, as well as ``dput`` to make sure that all packages in the
Launchpad PPA are up do date.
'''

import argparse
import functools
import os
import platform
import re
import subprocess

import colorcodes

__docformat__ = 'restructuredtext en'

_c = colorcodes.Colorcodes()

current_release = platform.dist()[2]
'''
Ubuntu release that the packages should be on.
'''

packages = sorted(os.listdir(os.path.expanduser('~/Packaging')))

public = [

    'a4-scan',
    'adium2pidgin',
    'bogomips'
    'chaos-repos',
    'copyright-updater',
    'email-rename',
    'git-changelog',
    'git-ignore-untracked',
    'git-tarball',
    'latex-edit',
    'legacy-file-formats',
    'lock-and-off',
    'maintenance',
    'mp3-packer',
    'multiimage',
    'open-in-browser',
    'pdflatex-multifont',
    'php-note-capture',
    'project-ubernahme',
    'python-colorcodes',
    'python-unitprint',
    'risk-auto-dice',
    'template-spawner',
    'tex-keywordprg',
    'think-rotate',
    'type-speed',
    'unwrap-pdf-to-jpeg',
    'urt-launcher',
    'van-allen-sim-3d',
    'vim-headings',
    'vim-regex-collecion',
    'xournal-page-count',

]
'''
List of packages that should be uploaded.
'''

upgrades = []

def p(command):
    '''
    Prints the given command.
    '''
    print('$ {}'.format(' '.join(command)))


basedir = os.path.expanduser('~/Packaging')
branchesdir = os.path.expanduser('~/Branches')

class PackagingError(Exception):
    '''
    General exception class for this script.
    '''
    pass


class Package(object):
    '''
    Models a Debian Package.
    '''
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return "Package('{}')".format(self.name)

    def auto(self):
        print()
        print(_c.cyan + self.name + _c.reset)
        print(_c.cyan + '-'*len(self.name) + _c.reset)
        print()

        os.chdir(basedir)

        self.export_latest()
        if self.needs_uupdate():
            self.uupdate()

        if self.name in public:
            if self.needs_building(True):
                self.build(True)
            try:
                self.upload()
            except PackagingError as e:
                print('Caught error, trying to build source again.')
                self.build(True)
                self.upload()

        if self.needs_building(False):
            self.build(False)

        needs_upgrade, installed, latest = self.needs_upgrade()
        if needs_upgrade:
            print(_c.orange + 'This package needs upgrading, {} → {}'.format(installed, latest) + _c.reset)
            upgrades.append('dpkg -i {}'.format(
                os.path.join(basedir, self.name, self.get_latest('.deb'))
            ))

    def build(self, source=True):
        '''
        Builds the given package, binary or source.
        '''
        latest_folder = self.get_latest_folder()

        os.chdir(os.path.join(basedir, self.name, latest_folder, 'debian'))
        sed_command = ['sed', '-i', 's/UNRELEASED/{}/'.format(current_release), 'changelog']
        subprocess.check_call(sed_command)

        os.chdir(os.path.join(basedir, self.name, self.get_latest_folder()))

        command = ['debuild']

        if source:
            command.append('-S')

        try:
            subprocess.check_call(command)
        except subprocess.CalledProcessError as e:
            print(e)
            raise PackagingError('Build failed.')

    def export_latest(self):
        '''
        Goes into the ``~/Branches`` folder and generates a tar archive with the
        latest version.

        Changes the current working directory.
        '''
        for d in [branchesdir, os.path.expanduser('~/.vim/bundle')]:
            try:
                os.chdir(os.path.join(branchesdir, self.name))
                subprocess.check_call(['git', 'tarball'])
            except subprocess.CalledProcessError:
                pass
            except OSError:
                pass

    def get_latest(self, suffix, function=None, folder=False):
        os.chdir(os.path.join(basedir, self.name))
        output = subprocess.check_output('ls | sort -V', shell=True)
        lines = output.decode().strip().split('\n')
        files = [x for x in lines
                 if (
                     (not folder and os.path.isfile(os.path.join(basedir, self.name, x)))
                     or (folder and os.path.isdir(os.path.join(basedir, self.name, x)))
                 )
                 and x.endswith(suffix)]

        if function is not None:
            files = [x for x in files if function(x)]

        if len(files) == 0:
            raise PackagingError('No latest *{} found'.format(suffix))

        return files[-1]

    def get_latest_folder(self):
        '''
        Retrieves the folder (without ``.orig``) which has the latest version
        number. If there is no such folder, ``None`` is returned.
        '''
        def function(x):
            return not x.endswith('.orig')

        return self.get_latest('', function, folder=True)

    def get_latest_tar(self):
        def function(x):
            return not x.endswith('.orig.tar.gz') and not x.endswith('.debian.tar.gz')

        return self.get_latest('.tar.gz', function)

    def installed_version(self):
        '''
        Checks ``apt-cache`` for the installed version of the package.

        I am aware that there is an ``apt`` module for Python which does the
        very thing. But feel lazy and just get it out of the output and parse
        that.
        '''
        try:
            command = ['apt-cache', 'show', self.name]
            output = subprocess.check_output(command)
        except subprocess.CalledProcessError as e:
            print(e)
        else:
            lines = output.decode().strip().split('\n')
            for line in lines:
                if line.startswith('Version:'):
                    words = line.strip().split()

                    return words[1]

    def needs_building(self, source=True):
        '''
        Checks whether the package needs to be build.

        It checks the latest ``.changes`` and ``.deb`` in the folder and
        compares them to the latest folder.
        '''
        os.chdir(os.path.join(basedir, self.name))

        latest_folder = self.get_latest_folder()
        if source:
            latest = self.get_latest('_source.changes')
        else:
            latest = self.get_latest('.deb')

        prefix = latest[:len(latest_folder)]
        prefix = prefix[:len(self.name)] + '-' + prefix[len(self.name) + 1:]

        return latest_folder != prefix

    def needs_upgrade(self):
        '''
        Checks whether the package needs to be updated.
        '''
        installed = self.installed_version()
        latest_deb = self.get_latest('.deb')
        pattern = r'{}_([^_]+)_.+\.deb'.format(self.name)
        m = re.match(pattern, latest_deb)
        if m:
            latest_version = m.group(1)

        return latest_version != installed, installed, latest_version

    def needs_uupdate(self):
        os.chdir(os.path.join(basedir, self.name))

        latest_folder = self.get_latest_folder()
        latest_tar = self.get_latest_tar()

        prefix = latest_tar[:-len('.tar.gz')]
        prefix = prefix[:len(self.name)] + '-' + prefix[len(self.name) + 1:]

        return latest_folder != prefix

    def upload(self):
        changes = self.get_latest('_source.changes')
        try:
            os.chdir(os.path.join(basedir, self.name))
            subprocess.check_call(['dput', 'stable', changes])
        except subprocess.CalledProcessError as e:
            print(e)
            raise PackagingError('Upload failed')

    def uupdate(self):
        '''
        Goes into the latest folder and calls ``uupdate`` onto the latest tar
        archive.

        After that, there should be a new latest folder.
        '''
        latest_tar = self.get_latest_tar()
        latest_folder = self.get_latest_folder()

        os.chdir(os.path.join(basedir, self.name, latest_folder))

        try:
            command = ['uupdate', '../'+latest_tar]
            subprocess.check_call(command)
        except subprocess.CalledProcessError as e:
            print(e)
            raise PackagingError('uupdate failed')


def main():
    options = _parse_args()

    if options.dry_run:
        subprocess.check_call = p

    for name in packages:
        try:
            package = Package(name)
            package.auto()
        except OSError as e:
            print(_c.red + str(e) + _c.reset)
            print(_c.red + 'Packaging of {0} failed.'.format(package) + _c.reset)
        except PackagingError as e:
            print(_c.red + str(e) + _c.reset)
            print(_c.red + 'Packaging of {0} failed.'.format(package) + _c.reset)

    if len(upgrades) > 0:
        print()
        print('possible upgrades')
        print('-----------------')
        print()
        for upgrade in upgrades:
            print(upgrade)


def _parse_args():
    '''
    Parses the command line arguments.

    :return: Namespace with arguments.
    :rtype: Namespace
    '''
    parser = argparse.ArgumentParser(description=__doc__)
    #parser.add_argument('args', metavar='N', type=str, nargs='*', help='Positional arguments.')
    #parser.add_argument('', dest='', type='', default=, help=)
    parser.add_argument('-n', dest='dry_run', action='store_true', default=False, help='dry run')
    #parser.add_argument('--version', action='version', version='<the version>')

    return parser.parse_args()

if __name__ == '__main__':
    main()
